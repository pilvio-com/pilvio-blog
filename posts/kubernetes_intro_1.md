Gemini

2.5 Pro (preview)

PRO



Show more


Conversation with Gemini
My intention is to become a medium level Kubernetes expert but I'm quite a beginner right now. I have a good understanding of Docker and conainerisation, have been setting up services with docker compose. I'm good with Linux, understand and use basic devops concepts. Can you guide me in that path?




Show thinking
Of course. Here is a guide to help you on your journey from a beginner to a medium-level Kubernetes expert.

This path is designed for someone with your background: a good understanding of Docker, containerization, docker-compose, Linux, and basic DevOps concepts.

ðŸš€ Your Kubernetes Learning Roadmap
This roadmap is broken down into three main phases: Foundation, Deep Dive, and Practical Application.

Phase 1: The Foundation (1-2 Months)
The goal of this phase is to build a solid understanding of Kubernetes architecture and its core concepts. You'll move from the single-host world of docker-compose to the distributed environment of Kubernetes.

Key Concepts to Master:
Kubernetes Architecture: Understand the components of a Kubernetes cluster: the control plane (API Server, etcd, Scheduler, Controller Manager) and worker nodes (Kubelet, Kube-proxy, Container Runtime).
Pods: The smallest deployable units in Kubernetes. Understand the Pod lifecycle and that a Pod can contain one or more containers. This is a key difference from just running a single Docker container.
Deployments: The standard way to run stateless applications. You'll learn how to declare the desired state of your application and let Kubernetes manage the rest, including creating and managing ReplicaSets.
Services: How you expose your applications running in Pods to the network (and the outside world). Understand the different types of Services: ClusterIP, NodePort, and LoadBalancer.
Namespaces: How to create logical partitions of your cluster for different projects or teams.
YAML Manifests: You will be writing a lot of YAML. Get comfortable with the syntax and structure of Kubernetes object definitions.
Recommended Learning Resources:
"Kubernetes: Up and Running, 3rd Edition" by Brendan Burns, Joe Beda, and Kelsey Hightower: A great book that provides a clear and concise introduction.
KodeKloud's "Kubernetes for the Absolute Beginners â€“ Hands-on" course: Excellent for its interactive labs that allow you to get your hands dirty right away.
TechWorld with Nana's "Kubernetes Crash Course for Absolute Beginners" on YouTube: A very popular and easy-to-follow visual introduction.
The official Kubernetes documentation: The "Concepts" and "Tasks" sections are invaluable. Don't be afraid to read them.
Hands-on Practice:
Install a local Kubernetes cluster: Use Minikube or Kind (Kubernetes in Docker) to run a single-node cluster on your machine. This is your personal sandbox.
Deploy a simple application: Take one of your existing docker-compose applications and manually create the Kubernetes YAML manifests for a Deployment and a Service. Get it running in your local cluster.
Phase 2: The Deep Dive (2-3 Months)
Now that you have the basics down, it's time to explore more advanced topics and understand how to manage more complex applications.

Key Concepts to Master:
Stateful Applications: Learn about StatefulSets for running databases and other stateful workloads. Understand the concepts of stable network identifiers and persistent storage.
Configuration Management: Use ConfigMaps to manage non-sensitive configuration data and Secrets to manage sensitive information like API keys and passwords.
Storage: Understand how Kubernetes handles storage with PersistentVolumes (PVs) and PersistentVolumeClaims (PVCs). This is crucial for stateful applications.
Networking: Go deeper into networking with Ingress controllers to manage external access to your services, and NetworkPolicies to secure communication between Pods.
RBAC (Role-Based Access Control): Learn how to secure your cluster by defining Roles and RoleBindings to control who can do what.
Helm: The package manager for Kubernetes. Learn how to use Helm charts to easily deploy and manage complex applications.
Recommended Learning Resources:
Continue with the resources from Phase 1 and delve into their more advanced sections.
"The Kubernetes Book" by Nigel Poulton: A very comprehensive and well-regarded book.
Certified Kubernetes Administrator (CKA) courses: Even if you don't plan to take the exam yet, courses from KodeKloud or on Udemy (like Mumshad Mannambeth's) provide a structured way to learn these intermediate topics.
Hands-on Practice:
Deploy a multi-tier application: Take a web application with a database (e.g., WordPress and MySQL) and deploy it on your local cluster. Use a Deployment for the frontend, a StatefulSet for the database, and connect them with a Service.
Set up an Ingress controller: Install an Ingress controller like NGINX Ingress Controller in your cluster and configure it to route traffic to your application.
Use Helm: Find a Helm chart for a popular application (e.g., Prometheus for monitoring) and deploy it to your cluster. Customize the deployment using a values.yaml file.
Phase 3: Practical Application & Specialization (Ongoing)
At this point, you'll have a solid intermediate understanding. The key now is to gain practical experience and start to specialize.

Key Areas of Focus:
CI/CD for Kubernetes: Learn how to build automated pipelines that build your Docker images and deploy them to your Kubernetes cluster using tools like Jenkins, GitLab CI, or GitHub Actions.
Monitoring and Logging: Understand how to monitor your cluster and applications using tools like Prometheus for metrics and Grafana for visualization. For logging, explore the EFK stack (Elasticsearch, Fluentd, Kibana).
Troubleshooting: Practice debugging common issues. Learn to use kubectl logs, kubectl describe, and kubectl exec effectively.
Cloud-Managed Kubernetes: Get familiar with at least one of the major cloud providers' managed Kubernetes services: Amazon EKS, Google GKE, or Azure AKS.
Recommended Learning and Practice:
Build a portfolio of projects: Create a GitHub repository where you store the YAML manifests and any automation scripts for the applications you deploy. This will be invaluable for job applications.
Contribute to open-source projects: Find a project that uses Kubernetes and see if you can contribute to their documentation or Helm charts.
Prepare for the Certified Kubernetes Administrator (CKA) exam: This is a great way to solidify your knowledge and get a valuable certification. The exam is hands-on and performance-based, so it forces you to become proficient with the command line.
By following this path and consistently engaging in hands-on practice, you'll be well on your way to becoming a confident and competent medium-level Kubernetes expert. Good luck! ðŸ¤“






can you teach me step by step?



Show thinking
Of course. Let's start your journey to becoming a Kubernetes expert, step by step. I will guide you through the very first, most fundamental concepts and actions. We'll build from the ground up, ensuring you understand each piece before moving to the next.

Let's begin with Step 1.

Step 1: Set Up Your Local Kubernetes Playground
Before you can do anything, you need a Kubernetes cluster to interact with. As a beginner, you don't need a massive, expensive cloud setup. A simple, local cluster on your own machine is the perfect way to start. We will use a tool called Minikube.

What is Minikube?
Minikube is a tool that creates a single-node Kubernetes cluster on your personal computer. Think of it as a mini-Kubernetes environment where you can safely experiment and learn without affecting anything else.

Your Action Items for Step 1:

Install a Hypervisor (if you don't have one): Minikube needs a virtual machine or container manager to run. Docker is the easiest option since you already have it installed and are comfortable with it. If you have Docker Desktop, you're all set.

Install kubectl: This is the command-line tool you will use to talk to your Kubernetes cluster. It's like the docker command, but for Kubernetes.

Official Instructions: Go to the official Kubernetes documentation to install kubectl. Follow the steps for your operating system (Linux).
Install Minikube:

Official Instructions: Visit the Minikube official site to install it. The instructions are straightforward for Linux, macOS, and Windows.
Start Your Cluster:

Open your terminal and run the following command. The --driver=docker flag tells Minikube to use Docker to create the cluster node.
<!-- end list -->

Bash

minikube start --driver=docker
What's happening? Minikube is now downloading the necessary components and creating a container on your machine that will act as your Kubernetes "node." This process might take a few minutes the first time.
Check Your Cluster's Status:

Once the start command finishes, verify that everything is working. Run:
<!-- end list -->

Bash

kubectl cluster-info
Expected Outcome: You should see output telling you the "Control plane" and "CoreDNS" are running at specific IP addresses. This confirms that kubectl can successfully connect to your new Minikube cluster.

You can also run:

<!-- end list -->

Bash

kubectl get nodes
Expected Outcome: You should see a single node named minikube with a status of Ready.
Congratulations! You now have a fully functional, single-node Kubernetes cluster running on your machine. You've installed the essential command-line tool, kubectl, and used it to communicate with your cluster.

This is a crucial first step. Don't rush it. Make sure you can comfortably start and check your cluster.

Once you are ready, let me know, and we'll move on to Step 2: Understanding and Creating Your First Pod.


Sources





explain the step 1 in greater detail, the kubectl and minicube part. what is the purpose of those components, how do they work, what was intalled?



Show thinking
Of course. Let's zoom in on Step 1 and break down kubectl and Minikube in much greater detail. It's crucial to understand what these tools are and how they interact.

The Big Picture: A Simple Analogy
To make this easy, let's use an analogy based on what you already know: Docker.

In the Docker world, you have the Docker Engine (the dockerd daemon). This is the "server" that actually does all the work of creating and running containers.
To talk to the Docker Engine, you use the docker command-line tool (the client). You type docker run or docker ps in your terminal.
Now, let's map this to Kubernetes:

Minikube creates and runs a miniature version of the Kubernetes "Server" on your local machine. This "server" is called the Control Plane.
kubectl is the command-line tool (the client) that you use to talk to that Kubernetes "Server" (the Control Plane).
So, the relationship is:
kubectl <---> Minikube Cluster (Control Plane)
...just like...
docker cli <---> Docker Engine

In-Depth Look at kubectl
1. What is its Purpose?

kubectl (pronounced "koob-control," "kube-cuddle," or "kube-C-T-L") is the single most important tool for interacting with a Kubernetes cluster. Its purpose is to be your "remote control" for the cluster. You use it to:

Deploy applications: Tell Kubernetes to run your containerized applications.
Inspect and manage resources: Check the status of your applications, see logs, and view all the different components running in the cluster.
Modify the cluster: Apply updates, scale your applications up or down, and change configurations.
Troubleshoot problems: If something goes wrong, kubectl is your primary tool for diagnosing the issue.
You will not be logging into the Kubernetes node and running commands there directly. Instead, you stay on your own machine and use kubectl to send instructions to the cluster's main entry point.

2. How does it Work?

The magic of kubectl lies in its communication with a component called the API Server.

Configuration File: When you installed kubectl, it created a hidden directory in your home folder called .kube. Inside it is a file named config. This file contains the address of your Kubernetes cluster and the credentials (certificates and keys) needed to securely connect to it.
minikube start updates the config: When you ran minikube start, it automatically found this .kube/config file and added a new "context" to it. This new context contains the specific IP address and security credentials for your newly created Minikube cluster.
Sending a Command: When you type a command like kubectl get nodes, the following happens:
kubectl reads the .kube/config file to find the address and credentials for the current cluster (in this case, your Minikube cluster).
It then forms a secure HTTPS request (an API call) and sends it over the network to the API Server running inside your Minikube cluster.
The API Server validates your request, performs the action (e.g., retrieves the list of nodes), and sends a response back.
kubectl receives this response and formats it nicely for you to read in your terminal.
3. What was Installed?

When you followed the installation steps, you downloaded a single, self-contained executable file named kubectl and placed it in a directory that is part of your system's PATH (like /usr/local/bin). This makes it so you can type kubectl from any location in your terminal. It isn't a complex installation with lots of dependencies; it's just one powerful binary file.

In-Depth Look at Minikube
1. What is its Purpose?

The purpose of Minikube is to give developers and learners a real, fully-functional, but simplified Kubernetes cluster that runs locally on one machine.

A production-grade Kubernetes cluster is complex, usually consisting of many physical or virtual servers. This is expensive and overkill for learning or development. Minikube solves this by squeezing all the essential parts of a Kubernetes cluster into a single "node" that runs inside a container or virtual machine on your laptop.

It allows you to:

Learn Kubernetes concepts without paying for cloud resources.
Develop and test your applications against a real Kubernetes API.
Ensure your application's YAML configuration files work before deploying them to a real, shared cluster.
2. How does it Work?

When you ran minikube start --driver=docker, here's what happened behind the scenes:

Driver Invocation: Minikube told your Docker Engine to download a specific container image that has all the Kubernetes components pre-installed.
Container Creation: Docker created a new container from that image. This container is special; it's a "node" that runs its own Linux system, container runtime, and all the necessary Kubernetes processes. From your host machine's perspective, it's just one Docker container. But inside that container, a whole Kubernetes cluster is running.
Cluster Bootstrapping: Inside the container, Minikube starts all the critical Control Plane components:
API Server: The gateway that kubectl talks to.
etcd: The highly reliable database for the cluster. All your YAML configurations and cluster state are stored here.
Scheduler: Decides which node should run a new application (in Minikube's case, there's only one node to choose from).
Controller Manager: Watches the state of the cluster and works to make sure the actual state matches the desired state you define in your YAML files.
Node Component Bootstrapping: It also starts the Worker Node components:
Kubelet: An agent that runs on the node, listens for instructions from the API Server, and manages containers on its behalf.
Kube-proxy: Manages network rules on the node to allow for communication between your applications.
3. What was Installed?

The minikube binary: Similar to kubectl, this is a single executable program that you use to start, stop, delete, and manage your local cluster.
The Minikube Docker Container: This is the big one. If you run docker ps in your terminal right now, you will see a container running named minikube. This container is your cluster. It contains everything needed for Kubernetes to function.
Configuration in .kube/config: As mentioned earlier, the connection details for this new cluster were added to your Kubernetes configuration file.
Cached Images: Minikube also caches container images and other assets in a hidden directory in your home folder (e.g., .minikube) to speed up subsequent starts.
I hope this detailed breakdown clarifies what you just accomplished in Step 1. You've set up a client (kubectl) and a server (the Minikube cluster) and successfully connected them. You're now ready to give that server some real work to do.

Ready to move on to Step 2: Understanding and Creating Your First Pod?


Sources





yes



Show thinking
Excellent. Let's move on to the most fundamental building block in Kubernetes.

Step 2: Understanding and Creating Your First Pod
In the Docker world, the basic unit is a container. In Kubernetes, the smallest and simplest deployable unit is a Pod. This is the first major concept you need to grasp.

What is a Pod?

Think of a Pod as a logical "wrapper" around one or more containers.

It's an environment: A Pod provides a shared execution environment for its containers. This means all containers inside the same Pod share the same network (they can talk to each other via localhost) and can share the same storage volumes.
Usually, it's one container: In 95% of use cases, a Pod contains just a single container. You can think of it as a "box" that you put your application container into. The main reason to have multiple containers in one Pod is when you have a tightly coupled "sidecar" helper container (e.g., for logging or service mesh). For now, just focus on the one-container-per-Pod model.
It's ephemeral: This is a critical point. Pods are designed to be mortal. They can be created, and they can die (if they crash or are terminated). You should never create a single, long-running Pod by itself and expect it to be resilient. We will handle reliability later with a different object called a "Deployment". For now, we are just learning about the Pod itself.
Your Action Items for Step 2:

We will create a Pod in two different ways. First, the quick and easy way, and second, the "correct" and standard way.

Method 1: The Imperative Way (kubectl run)

This method is a direct command to the cluster, saying "Go run this for me now." It's great for quick tests.

Create a Pod: In your terminal, run the following command. This tells Kubernetes to create a Pod named my-first-pod using the NGINX web server image.

Bash

kubectl run my-first-pod --image=nginx
What's happening? kubectl sends a request to the API Server. The Scheduler assigns the new Pod to your minikube node. The Kubelet on that node gets the instruction and tells its container runtime (Docker, in this case) to pull the nginx image and start a container. All of this is wrapped inside a Pod resource.
Check the Pod's Status: Now, let's see if it's running.

Bash

kubectl get pods
Expected Outcome: You'll see a line with my-first-pod. It might say ContainerCreating for a few seconds, and then it should change to Running.
NAME           READY   STATUS    RESTARTS   AGE
my-first-pod   1/1     Running   0          30s
Get More Details: To inspect the Pod more closely, use the describe command. This is your go-to command for troubleshooting.

Bash

kubectl describe pod my-first-pod
Expected Outcome: This will give you a lot of information, including the Pod's IP address within the cluster, the image it's using, and most importantly, an "Events" log at the bottom showing you the steps Kubernetes took to create the Pod.
Clean Up: Now that you've seen it, let's delete it.

Bash

kubectl delete pod my-first-pod
Method 2: The Declarative Way (YAML Manifest)

This is the standard, professional way to work with Kubernetes. Instead of telling Kubernetes what to do, you write a YAML file that describes what you want. You give this file to Kubernetes, and Kubernetes works to make the cluster's state match your file. This is a core principle of "Infrastructure as Code."

Create the YAML File: Create a new file named pod.yaml and put the following content into it. YAML is very sensitive to indentation, so make sure to use spaces, not tabs, and keep the structure exact.

YAML

apiVersion: v1
kind: Pod
metadata:
  name: my-second-pod
  labels:
    app: webserver
spec:
  containers:
  - name: nginx-container
    image: nginx
Let's break this down:
apiVersion: v1: Tells Kubernetes which version of the API to use to create this object. For Pods, it's v1.
kind: Pod: Specifies that the object you want to create is a Pod.
metadata: Data about the object, like its name and labels (which are very important for organizing things later).
spec: The most important part. This is the desired state. Here we are specifying the containers we want in the Pod. We define a container with a name (nginx-container) and the image it should use (nginx).
Apply the Manifest: Now, tell Kubernetes to create whatever is defined in this file.

Bash

kubectl apply -f pod.yaml
Expected Outcome: You will see the message pod/my-second-pod created.
Check the Result: Use the same commands as before to see your new Pod.

Bash

kubectl get pods
kubectl describe pod my-second-pod
You will see your my-second-pod running, just like the first one.

Clean Up: You can delete the Pod using the same file.

Bash

kubectl delete -f pod.yaml
Congratulations! You've now created, inspected, and deleted the fundamental unit of work in Kubernetes. You've also seen the two primary ways of interacting with the cluster: the imperative way for quick actions, and the declarative way (YAML) for defining the state of your applications, which is how you will work professionally.

Take your time to digest this. When you're ready and comfortable with the concept of a Pod, let me know, and we will move on to Step 3: Exposing Your Pod with Services.






let's move on



Show thinking
Excellent. Now you have a Pod running your application, but there's a problem: how do you access it?

A Pod's IP address is internal to the cluster and, more importantly, it's temporary. If the Pod crashes and is recreated, it will come back with a new IP address. You can't rely on it.

This is where Services come in. They solve this exact problem.

Step 3: Making Pods Reachable with a Service
A Service is a stable network endpoint that directs traffic to a group of Pods. It acts as a durable, internal load balancer.

Stable IP Address: A Service gets its own IP address that does not change.
Label Selectors: How does a Service know which Pods to send traffic to? It uses the labels we defined in the Pod's metadata. This is a crucial mechanism. The Service creates a query: "continuously find all Pods that have the label app: webserver and send traffic to them."
Decoupling: This creates a clean separation. Your frontend Pods don't need to know the individual IP addresses of the backend Pods. They just need to know the stable IP address of the backend Service.
For this step, we'll introduce a new object that is better than a standalone Pod: a Deployment. Think of a Deployment as a manager for your Pods that ensures a specified number of them are always running. If a Pod crashes, the Deployment automatically creates a new one. This is how you run stateless applications in production.

Your Action Items for Step 3:

Create a Deployment Manifest:
Instead of a pod.yaml, we'll create a deployment.yaml. This file tells Kubernetes you want a Deployment named nginx-deployment that will maintain 2 replicas (two identical Pods) of your NGINX application. Notice the labels under metadata and the selector in the spec. They are how the Deployment knows which Pods to manage.

Create a file named deployment.yaml:

YAML

apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: webserver
  template: # This is the Pod template!
    metadata:
      labels:
        app: webserver
    spec:
      containers:
      - name: nginx
        image: nginx
        ports:
        - containerPort: 80 # The port the container is listening on
Apply the Deployment Manifest:
This single command will create the Deployment, which in turn will create a ReplicaSet, which in turn will create your two Pods.

Bash

kubectl apply -f deployment.yaml
Check the Status:
Run kubectl get pods. You'll now see two Pods running, with names like nginx-deployment-xxxxxxxx-yyyyy.

Bash

kubectl get pods
Expected Outcome:
NAME                                READY   STATUS    RESTARTS   AGE
nginx-deployment-7848d4b8d5-7c5jc   1/1     Running   0          25s
nginx-deployment-7848d4b8d5-x5zvm   1/1     Running   0          25s
Create the Service Manifest:
Now, let's create the Service to provide a single, stable entry point to these two Pods.
Create a file named service.yaml:

YAML

apiVersion: v1
kind: Service
metadata:
  name: my-nginx-service
spec:
  type: ClusterIP # The default type, reachable only from within the cluster.
  selector:
    app: webserver # This is the magic link!
  ports:
    - protocol: TCP
      port: 80       # The port the Service will be available on.
      targetPort: 80 # The port on the Pods to forward traffic to.
Breaking it down:
type: ClusterIP: This makes the Service reachable only from inside the Kubernetes cluster. It's perfect for internal, backend communication.
selector: app: webserver: This is the most important line. It tells the Service to look for any Pod with the label app: webserver and automatically include it in the group of endpoints. This matches the label we put in our Deployment's Pod template.
Apply the Service Manifest:

Bash

kubectl apply -f service.yaml
Verify the Service:
Now, check that your Service was created.

Bash

kubectl get service my-nginx-service
Expected Outcome: You will see your service with a CLUSTER-IP (an internal IP address).

NAME               TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE
my-nginx-service   ClusterIP   10.108.111.44   <none>        80/TCP    15s
Test the Service:
So how do we prove it works? We can't access that CLUSTER-IP from our own machine's browser because it's internal to the cluster. But we can run a temporary Pod inside the cluster and use a command-line tool like curl from there.

Run this command:

Bash

# This runs a temporary pod and gives you a shell inside it.
# We use --rm so the pod is automatically deleted when we exit.
kubectl run tmp-pod --rm -i --tty --image=alpine -- /bin/sh
Once you get a shell prompt (/ #), run the following. Replace 10.108.111.44 with the CLUSTER-IP you saw in the previous step.

Bash

# Inside the temporary pod's shell
apk add curl
curl http://10.108.111.44
Expected Outcome: You should see the default "Welcome to nginx!" HTML page. You just accessed one of your NGINX pods via the stable Service IP! If you were to run the curl command multiple times, the Service would load-balance your requests between the two available Pods.
Type exit to leave the temporary pod's shell.
Clean Up:
To delete everything you created in this step, just delete the objects from the files.

Bash

kubectl delete -f deployment.yaml
kubectl delete -f service.yaml
Congratulations! This was a big and very important step. You have now learned how to:

Reliably run an application using a Deployment.
Understand the concept of Labels and Selectors.
Create a stable network endpoint for your application using a Service.
Test internal connectivity within the cluster.
You are now working with Kubernetes in a much more realistic and powerful way. When you're ready, let me know, and we'll proceed to Step 4: Exposing Your Application to the Outside World with Ingress.


Sources





based on the learning steps, please write a Digital Ocean style blogpost "Introduction to Kubernetes". in Estonian please. that's a 1st blogpost in the series. mention, that the reader is expected to have basic docker knowledge. For setting up minicube on Pilvio refer to blog post at https://blog.pilvio.com/blog/minikube-terraform




Show thinking
Muidugi, siin on Digital Oceani stiilis blogipostitus, mis pÃµhineb meie eelnevatel Ãµpisammudel ja on kirjutatud eesti keeles.

Sissejuhatus Kubernetesesse: Sinu esimene rakendus
Tere tulemast meie uude blogiseeriasse, mis on pÃ¼hendatud Kubernetesesse sisseelamisele! See on esimene postitus, mis aitab sul astuda esimesi samme konteinerite orkestreerimismaailmas. Kubernetes, tihti lÃ¼hendatud kui K8s, on vÃµimas avatud lÃ¤htekoodiga platvorm, mis automatiseerib konteineriseeritud rakenduste paigaldamist, skaleerimist ja haldamist.

Kui oled tuttav Dockeriga ja docker-compose'iga, siis tead, kui lihtne on hallata rakendusi Ã¼hes masinas. Aga mis juhtub siis, kui sinu rakendus peab olema kÃ¤ideldav, skaleeruma vastavalt koormusele ja end ise parandama, kui midagi lÃ¤heb valesti? Siin tulebki mÃ¤ngu Kubernetes.

Selles postituses juhendame sind lÃ¤bi Kubernetes'e pÃµhikontseptsioonide, alustades sinu esimese rakenduse paigaldamisest kuni selle kÃ¤ttesaadavaks tegemiseni klastri sees.

Eeldused
Enne alustamist eeldame, et sul on:

PÃµhiteadmised Dockerist ja konteineritest. Sa mÃµistad, mis on tÃµmmis (image) ja mis on konteiner.
Soov Ãµppida ja katsetada kÃ¤sureal.
Selles juhendis kasutame kohaliku arenduskeskkonna jaoks Minikube'i. Meie hea partner Pilvio on kirjutanud suurepÃ¤rase juhendi, kuidas seadistada Minikube koos Terraformiga nende platvormil. Palun jÃ¤rgi nende juhiseid, et oma Kubernetes'e testkeskkond pÃ¼sti panna: Kuidas paigaldada Minikube Pilvios Terraformiga.

Kui Minikube on seadistatud ja kubectl kÃ¤surida tÃ¶Ã¶tab, oled valmis alustama!

Samm 1: Sinu esimene Pod
KÃµige vÃ¤iksem ja fundamentaalsem ehituskivi Kuberneteses on Pod. MÃµtle sellest kui Ã¼hest vÃµi mitmest konteinerist koosnevast grupist, mis jagavad sama vÃµrgu- ja salvestusruumi. Enamasti jookseb Ã¼hes Podis Ã¼ks konteiner. Pod on aga "surelik" â€“ kui see hÃ¤vineb, on see jÃ¤Ã¤davalt kadunud. SeetÃµttu ei loo me peaaegu kunagi Pade otse, vaid kasutame selleks kÃµrgema taseme objekte.

Alustame siiski Podi loomisega, et mÃµista selle kontseptsiooni. Loome selle deklaratiivselt, kasutades YAML-faili â€“ see on standardne viis Kuberneteses ressursside defineerimiseks.

Loo fail nimega pod.yaml:

YAML

apiVersion: v1
kind: Pod
metadata:
  name: minu-esimene-pod
  labels:
    app: veebiserver
spec:
  containers:
  - name: nginx-konteiner
    image: nginx
Selles failis me defineerime:

kind: Pod: anname teada, et loome Pod'i.
metadata: anname Pod'ile nime ja sildi (label), mille abil saame selle hiljem Ã¼les leida.
spec: kirjeldame Pod'i soovitud olekut, mis antud juhul on Ã¼ks konteiner, mis kasutab nginx'i tÃµmmist.
NÃ¼Ã¼d paigaldame selle oma klastrisse kubectl apply kÃ¤suga:

Bash

kubectl apply -f pod.yaml
Sa peaksid nÃ¤gema vastust: pod/minu-esimene-pod created.

Kontrollime, kas meie Pod tÃ¶Ã¶tab:

Bash

kubectl get pods
VÃ¤ljund peaks nÃ¤itama, et minu-esimene-pod on staatuses Running:

NAME                READY   STATUS    RESTARTS   AGE
minu-esimene-pod    1/1     Running   0          30s
SuurepÃ¤rane! Sa oled loonud oma esimese ressursi Kuberneteses. NÃ¼Ã¼d koristame selle Ã¤ra, et liikuda edasi parema praktika juurde.

Bash

kubectl delete -f pod.yaml
Samm 2: UsaldusvÃ¤Ã¤rne rakendus Deploymentiga
Nagu mainitud, on Podid Ã¼ksi haprad. Et meie rakendus oleks vastupidav ja skaleeritav, kasutame Deployment'i. Deployment on kontroller, mis hoolitseb selle eest, et sinu mÃ¤Ã¤ratud arv Pod'i replikaid (koopiaid) oleks alati tÃ¶Ã¶s. Kui mÃµni Pod peaks kokku jooksma, loob Deployment automaatselt uue asemele.

Loome faili deployment.yaml:

YAML

apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: veebiserver
  template:
    metadata:
      labels:
        app: veebiserver
    spec:
      containers:
      - name: nginx
        image: nginx
        ports:
        - containerPort: 80
MÃ¤rkad, et see fail sarnaneb Pod'i definitsioonile. Olulisemad erinevused on:

kind: Deployment: anname teada, et loome Deployment'i.
replicas: 2: anname korralduse hoida tÃ¶Ã¶s kahte identset Pod'i.
selector: see on Ã¼lioluline. Deployment kasutab seda matchLabels reeglit, et teada, millised Podid kuuluvad tema haldusalasse.
template: see on Pod'i mall, mille pÃµhjal Deployment uusi Pod'e loob. Paneme tÃ¤hele, et siin on sama silt (label) app: veebiserver, mis on ka selektoris.
Paigaldame Deployment'i:

Bash

kubectl apply -f deployment.yaml
Kontrollime tulemust:

Bash

kubectl get pods
NÃ¼Ã¼d peaksid nÃ¤gema kahte NGINX Pod'i, mille nimed on genereerinud Deployment:

NAME                                READY   STATUS    RESTARTS   AGE
nginx-deployment-7848d4b8d5-7c5jc   1/1     Running   0          25s
nginx-deployment-7848d4b8d5-x5zvm   1/1     Running   0          25s
Samm 3: Rakenduse kÃ¤ttesaadavaks tegemine Service'iga
Meil on nÃ¼Ã¼d kaks Pod'i, aga mÃµlemal on oma dÃ¼naamiline IP-aadress, mis vÃµib iga hetk muutuda. Kuidas saaks teine rakendus meie NGINX teenust stabiilselt kasutada? Lahendus on Service.

Service on abstraktne kiht, mis loob stabiilse IP-aadressi ja DNS nime klastri sees ning suunab liikluse Ãµigete Podideni, kasutades nende silte (labels).

Loome faili service.yaml:

YAML

apiVersion: v1
kind: Service
metadata:
  name: minu-nginx-service
spec:
  type: ClusterIP
  selector:
    app: veebiserver
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
Siin on oluline:

type: ClusterIP: See on vaikimisi tÃ¼Ã¼p, mis teeb teenuse kÃ¤ttesaadavaks ainult klastri-siseselt.
selector: app: veebiserver: See on maagiline Ã¼henduslÃ¼li. Service leiab selle sildi abil kÃµik Podid (mille meie Deployment lÃµi) ja suunab liikluse neile.
port ja targetPort: Service avab pordi 80 ja suunab liikluse Pod'ide pordile 80.
Paigaldame Service'i:

Bash

kubectl apply -f service.yaml
Kontrollime, kas Service on loodud:

Bash

kubectl get service minu-nginx-service
VÃ¤ljund nÃ¤itab, et meie teenusel on nÃ¼Ã¼d stabiilne klastri-sisene IP-aadress (CLUSTER-IP):

NAME                 TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE
minu-nginx-service   ClusterIP   10.108.111.44   <none>        80/TCP    15s
NÃ¼Ã¼d on meie NGINX rakendus kÃ¤ttesaadav mistahes teisest Pod'ist klastri sees, kasutades kas IP-aadressi 10.108.111.44 vÃµi DNS nime minu-nginx-service.

KokkuvÃµte
Palju Ãµnne! Sa oled edukalt loonud oma esimese rakenduse Kuberneteses.

Mida sa tÃ¤na Ãµppisid:

Mis on Kubernetes'e pÃµhilised ehituskivid: Pod, Deployment ja Service.
Kuidas kasutada kubectl kÃ¤surida ressursside paigaldamiseks YAML-failidest.
Kuidas luua tÃ¶Ã¶kindel rakendus Deployment'iga ja pakkuda sellele stabiilne vÃµrguaadress Service'iga.
Hetkel on meie rakendus kÃ¤ttesaadav ainult klastri seest. Meie seeria jÃ¤rgmises postituses vaatame, kuidas oma rakendus turvaliselt ka vÃ¤lismaailmale avada, kasutades selleks Ingress'i. PÃ¼sige lainel!


Sources





Ã„ra viita Pilviole kui kolmandale partnerile. Meie olemegi Pilvio! Muidu on artikkel hea, Ã¤ra muud sisu muuda. Lisa ainult osa, kus rÃ¤Ã¤gid minicube'ist ja kubectl'ist, nagu meie lÃ¤bi kÃ¤isime.




Show thinking
Muidugi, siin on parandatud ja tÃ¤iendatud versioon blogipostitusest, mis arvestab sinu tagasisidet.

Sissejuhatus Kubernetesesse: Sinu esimene rakendus
Tere tulemast meie blogiseeriasse, mis on pÃ¼hendatud Kubernetesesse sisseelamisele! See on esimene postitus, mis aitab sul astuda esimesi samme konteinerite orkestreerimismaailmas. Kubernetes, tihti lÃ¼hendatud kui K8s, on vÃµimas avatud lÃ¤htekoodiga platvorm, mis automatiseerib konteineriseeritud rakenduste paigaldamist, skaleerimist ja haldamist.

Kui oled tuttav Dockeriga ja docker-compose'iga, siis tead, kui lihtne on hallata rakendusi Ã¼hes masinas. Aga mis juhtub siis, kui sinu rakendus peab olema kÃ¤ideldav, skaleeruma vastavalt koormusele ja end ise parandama, kui midagi lÃ¤heb valesti? Siin tulebki mÃ¤ngu Kubernetes.

Selles postituses juhendame sind lÃ¤bi Kubernetes'e pÃµhikontseptsioonide, alustades sinu esimese rakenduse paigaldamisest kuni selle kÃ¤ttesaadavaks tegemiseni klastri sees.

Eeldused
Enne alustamist eeldame, et sul on:

PÃµhiteadmised Dockerist ja konteineritest. Sa mÃµistad, mis on tÃµmmis (image) ja mis on konteiner.
Soov Ãµppida ja katsetada kÃ¤sureal.
Selles juhendis kasutame kohaliku arenduskeskkonna jaoks Minikube'i. Siin Pilvios oleme kirjutanud eraldi pÃµhjaliku juhendi, kuidas seadistada Minikube koos Terraformiga meie platvormil. Palun jÃ¤rgi neid juhiseid, et oma Kubernetes'e testkeskkond pÃ¼sti panna: Kuidas paigaldada Minikube Pilvios Terraformiga.

Kui oled sellega valmis, liigume edasi.

TÃ¶Ã¶riistade MÃµistmine: kubectl ja Minikube
Enne kui loome oma esimese rakenduse, on Ã¼lioluline mÃµista kahte pÃµhilist tÃ¶Ã¶riista, mille just seadistasid: kubectl ja Minikube.

Analoogia Dockeriga teeb sellest arusaamise lihtsaks:

Dockeri maailmas on sul Docker Engine (server), mis teeb kogu tÃ¶Ã¶, ja docker CLI (klient), millega sa serverile kÃ¤ske annad.
Kubernetes'e maailmas loob Minikube sulle miniatuurse Kubernetes'e serveri (mida kutsutakse Control Plane'iks) ja kubectl on sinu klient, millega sa sellele serverile kÃ¤ske annad.
kubectl: Sinu Kaugjuhtimispult
kubectl (hÃ¤Ã¤ldatakse "kjuub-kontroll") on sinu peamine ja kÃµige olulisem tÃ¶Ã¶riist Kubernetes'e klastriga suhtlemiseks. Sa ei logi kunagi otse Kubernetes'e masinasse, vaid annad kÃµik kÃ¤sud oma arvutist kubectl'i kaudu.

Kuidas see tÃ¶Ã¶tab?
Iga kord, kui sa kÃ¤ivitad kÃ¤su nagu kubectl get nodes, teeb kubectl jÃ¤rgmist:

Loeb konfiguratsiooni: See leiab sinu kodukataloogist .kube/config faili. Minikube'i kÃ¤ivitamisel lisati sinna automaatselt sinu uue lokaalse klastri aadress ja turvasertifikaadid.
Saadab API pÃ¤ringu: kubectl vÃµtab sinu kÃ¤su, vormistab selle turvaliseks HTTPS-pÃ¤ringuks ja saadab selle sinu Minikube'i klastris jooksvale API Serverile.
NÃ¤itab vastust: API Server teeb nÃµutud tegevuse, saadab vastuse tagasi ja kubectl vormindab selle sinu terminalis loetavaks.
See on sinu universaalne pult rakenduste paigaldamiseks, haldamiseks ja probleemide diagnoosimiseks.

Minikube: Sinu Isiklik Kubernetes'e Klaster
Minikube'i eesmÃ¤rk on anda sulle tÃ¤isfunktsionaalne, aga lihtsustatud Kubernetes'e klaster, mis jookseb sinu enda arvutis. See vÃ¤ldib vajadust kasutada arenduseks ja Ãµppimiseks kalleid pilveressursse.

Kuidas see tÃ¶Ã¶tab?
Kui sa kÃ¤ivitasid minikube start, tegi see taustal jÃ¤rgmist:

KÃ¤ivitas konteineri: Minikube andis sinu Dockerile korralduse kÃ¤ivitada spetsiaalne konteiner. See konteiner on sinu Kubernetes'e klaster.
KÃ¤ivitas komponendid: Selle konteineri sees pani Minikube tÃ¶Ã¶le kÃµik Kubernetes'e elutÃ¤htsad osad: API Serveri (sinu pultide vastuvÃµtja), etcd (klastri andmebaas), Scheduler'i (mis otsustab, kuhu rakendused paigutada) ja palju muud.
NÃ¼Ã¼d, kui me mÃµistame oma tÃ¶Ã¶riistu, oleme valmis looma oma esimese rakenduse.

Samm 1: Sinu esimene Pod
KÃµige vÃ¤iksem ja fundamentaalsem ehituskivi Kuberneteses on Pod. MÃµtle sellest kui Ã¼hest vÃµi mitmest konteinerist koosnevast grupist, mis jagavad sama vÃµrgu- ja salvestusruumi. Enamasti jookseb Ã¼hes Podis Ã¼ks konteiner. Pod on aga "surelik" â€“ kui see hÃ¤vineb, on see jÃ¤Ã¤davalt kadunud. SeetÃµttu ei loo me peaaegu kunagi Pade otse, vaid kasutame selleks kÃµrgema taseme objekte.

Alustame siiski Podi loomisega, et mÃµista selle kontseptsiooni. Loome selle deklaratiivselt, kasutades YAML-faili â€“ see on standardne viis Kuberneteses ressursside defineerimiseks.

Loo fail nimega pod.yaml:

YAML

apiVersion: v1
kind: Pod
metadata:
  name: minu-esimene-pod
  labels:
    app: veebiserver
spec:
  containers:
  - name: nginx-konteiner
    image: nginx
Selles failis me defineerime:

kind: Pod: anname teada, et loome Pod'i.
metadata: anname Pod'ile nime ja sildi (label), mille abil saame selle hiljem Ã¼les leida.
spec: kirjeldame Pod'i soovitud olekut, mis antud juhul on Ã¼ks konteiner, mis kasutab nginx'i tÃµmmist.
NÃ¼Ã¼d paigaldame selle oma klastrisse kubectl apply kÃ¤suga:

Bash

kubectl apply -f pod.yaml
Sa peaksid nÃ¤gema vastust: pod/minu-esimene-pod created.

Kontrollime, kas meie Pod tÃ¶Ã¶tab:

Bash

kubectl get pods
VÃ¤ljund peaks nÃ¤itama, et minu-esimene-pod on staatuses Running:

NAME                READY   STATUS    RESTARTS   AGE
minu-esimene-pod    1/1     Running   0          30s
SuurepÃ¤rane! Sa oled loonud oma esimese ressursi Kuberneteses. NÃ¼Ã¼d koristame selle Ã¤ra, et liikuda edasi parema praktika juurde.

Bash

kubectl delete -f pod.yaml
Samm 2: UsaldusvÃ¤Ã¤rne rakendus Deploymentiga
Nagu mainitud, on Podid Ã¼ksi haprad. Et meie rakendus oleks vastupidav ja skaleeritav, kasutame Deployment'i. Deployment on kontroller, mis hoolitseb selle eest, et sinu mÃ¤Ã¤ratud arv Pod'i replikaid (koopiaid) oleks alati tÃ¶Ã¶s. Kui mÃµni Pod peaks kokku jooksma, loob Deployment automaatselt uue asemele.

Loome faili deployment.yaml:

YAML

apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: veebiserver
  template:
    metadata:
      labels:
        app: veebiserver
    spec:
      containers:
      - name: nginx
        image: nginx
        ports:
        - containerPort: 80
MÃ¤rkad, et see fail sarnaneb Pod'i definitsioonile. Olulisemad erinevused on:

kind: Deployment: anname teada, et loome Deployment'i.
replicas: 2: anname korralduse hoida tÃ¶Ã¶s kahte identset Pod'i.
selector: see on Ã¼lioluline. Deployment kasutab seda matchLabels reeglit, et teada, millised Podid kuuluvad tema haldusalasse.
template: see on Pod'i mall, mille pÃµhjal Deployment uusi Pod'e loob. Paneme tÃ¤hele, et siin on sama silt (label) app: veebiserver, mis on ka selektoris.
Paigaldame Deployment'i:

Bash

kubectl apply -f deployment.yaml
Kontrollime tulemust:

Bash

kubectl get pods
NÃ¼Ã¼d peaksid nÃ¤gema kahte NGINX Pod'i, mille nimed on genereerinud Deployment:

NAME                                READY   STATUS    RESTARTS   AGE
nginx-deployment-7848d4b8d5-7c5jc   1/1     Running   0          25s
nginx-deployment-7848d4b8d5-x5zvm   1/1     Running   0          25s
Samm 3: Rakenduse kÃ¤ttesaadavaks tegemine Service'iga
Meil on nÃ¼Ã¼d kaks Pod'i, aga mÃµlemal on oma dÃ¼naamiline IP-aadress, mis vÃµib iga hetk muutuda. Kuidas saaks teine rakendus meie NGINX teenust stabiilselt kasutada? Lahendus on Service.

Service on abstraktne kiht, mis loob stabiilse IP-aadressi ja DNS nime klastri sees ning suunab liikluse Ãµigete Podideni, kasutades nende silte (labels).

Loome faili service.yaml:

YAML

apiVersion: v1
kind: Service
metadata:
  name: minu-nginx-service
spec:
  type: ClusterIP
  selector:
    app: veebiserver
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
Siin on oluline:

type: ClusterIP: See on vaikimisi tÃ¼Ã¼p, mis teeb teenuse kÃ¤ttesaadavaks ainult klastri-siseselt.
selector: app: veebiserver: See on maagiline Ã¼henduslÃ¼li. Service leiab selle sildi abil kÃµik Podid (mille meie Deployment lÃµi) ja suunab liikluse neile.
port ja targetPort: Service avab pordi 80 ja suunab liikluse Pod'ide pordile 80.
Paigaldame Service'i:

Bash

kubectl apply -f service.yaml
Kontrollime, kas Service on loodud:

Bash

kubectl get service minu-nginx-service
VÃ¤ljund nÃ¤itab, et meie teenusel on nÃ¼Ã¼d stabiilne klastri-sisene IP-aadress (CLUSTER-IP):

NAME                 TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE
minu-nginx-service   ClusterIP   10.108.111.44   <none>        80/TCP    15s
NÃ¼Ã¼d on meie NGINX rakendus kÃ¤ttesaadav mistahes teisest Pod'ist klastri sees, kasutades kas IP-aadressi 10.108.111.44 vÃµi DNS nime minu-nginx-service.

KokkuvÃµte
Palju Ãµnne! Sa oled edukalt loonud oma esimese rakenduse Kuberneteses.

Mida sa tÃ¤na Ãµppisid:

Mis on Kubernetes'e pÃµhilised tÃ¶Ã¶riistad kubectl ja Minikube.
Mis on Kubernetes'e pÃµhilised ehituskivid: Pod, Deployment ja Service.
Kuidas kasutada kubectl kÃ¤surida ressursside paigaldamiseks YAML-failidest.
Kuidas luua tÃ¶Ã¶kindel rakendus Deployment'iga ja pakkuda sellele stabiilne vÃµrguaadress Service'iga.
Hetkel on meie rakendus kÃ¤ttesaadav ainult klastri seest. Meie seeria jÃ¤rgmises postituses vaatame, kuidas oma rakendus turvaliselt ka vÃ¤lismaailmale avada, kasutades selleks Ingress'i. PÃ¼sige lainel!


Sources





Hea artikkel. Soovin, et selgitaksid asju veel pÃµhjalikumalt, tooksid analooge ja nÃ¤iteid iga sammu juures



Show thinking
Absoluutselt. Siin on sama artikkel, aga palju pÃµhjalikumalt lahti seletatud, kasutades iga sammu juures analoogiaid ja detailsemaid nÃ¤iteid, et muuta Kubernetes'e maailm veelgi arusaadavamaks.

Sissejuhatus Kubernetesesse: Sinu Esimene Rakendus (PÃµhjalik Juhend)
Tere tulemast meie blogiseeriasse, mis on pÃ¼hendatud Kubernetesesse sisseelamisele! See on esimene postitus, mis aitab sul astuda esimesi samme konteinerite orkestreerimismaailmas. Kubernetes, tihti lÃ¼hendatud kui K8s, on vÃµimas avatud lÃ¤htekoodiga platvorm, mis automatiseerib konteineriseeritud rakenduste paigaldamist, skaleerimist ja haldamist.

MÃµtle Kubernetesest kui sÃ¼mfooniaorkestri dirigendist. Sinu rakendused on muusikud. Dockeriga saad sa Ã¶elda igale muusikule (konteinerile), mida mÃ¤ngida. Aga Kubernetes on dirigent, kes juhatab kogu orkestrit: ta tagab, et kÃµik alustavad Ãµigel ajal, mÃ¤ngivad harmoonias, asendab muusiku, kui see peaks Ã¤ra vÃ¤sima, ja toob juurde uusi viiuleid, kui muusika peab muutuma vÃµimsamaks.

Selles postituses juhendame sind lÃ¤bi Kubernetes'e pÃµhikontseptsioonide, alustades sinu esimese rakenduse paigaldamisest kuni selle kÃ¤ttesaadavaks tegemiseni klastri sees.

Eeldused
Enne alustamist eeldame, et sul on:

PÃµhiteadmised Dockerist ja konteineritest. Sa mÃµistad, mis on tÃµmmis (image) ja mis on konteiner.
Soov Ãµppida ja katsetada kÃ¤sureal.
Selles juhendis kasutame kohaliku arenduskeskkonna jaoks Minikube'i. Siin Pilvios oleme kirjutanud eraldi pÃµhjaliku juhendi, kuidas seadistada Minikube koos Terraformiga meie platvormil. Palun jÃ¤rgi neid juhiseid, et oma Kubernetes'e testkeskkond pÃ¼sti panna: Kuidas paigaldada Minikube Pilvios Terraformiga.

Kui oled sellega valmis, liigume edasi.

TÃ¶Ã¶riistade MÃµistmine: kubectl ja Minikube
Enne kui loome oma esimese rakenduse, on Ã¼lioluline mÃµista kahte pÃµhilist tÃ¶Ã¶riista, mille just seadistasid: kubectl ja Minikube.

kubectl: Sinu Kaugjuhtimispult
kubectl (hÃ¤Ã¤ldatakse "kjuub-kontroll") on sinu peamine ja kÃµige olulisem tÃ¶Ã¶riist Kubernetes'e klastriga suhtlemiseks.

Analoogia: MÃµtle kubectl-ist kui oma teleri kaugjuhtimispuldist. Pult ise ei tea, kuidas teleri sisemine elektroonika pilti tekitab. Sa lihtsalt vajutad nuppu "Kanal 5" ja teler teab, mida teha. kubectl on samasugune â€“ sa annad kÃ¤su (kubectl get pods) ja ei pea muretsema, kuidas klaster selle info tÃ¤pselt hangib. Sa suhtled ainult puldiga, mitte ei hakka teleri tagapaneeli lahti kruvima.

Kuidas see tÃ¶Ã¶tab?
Iga kord, kui sa kÃ¤ivitad kÃ¤su, teeb kubectl jÃ¤rgmist:

Loeb konfiguratsiooni: Sinu kodukataloogis on peidetud fail .kube/config. See on nagu puldi ja teleri "paaristamise" info. Sinna on kirja pandud sinu Minikube'i klastri unikaalne aadress ja turvavÃµtmed, mis tÃµestavad, et just sinul on Ãµigus sellele klastrile kÃ¤ske anda.
Saadab API pÃ¤ringu: kubectl vormistab sinu kÃ¤su standardseks API-pÃ¤ringuks ja saadab selle Ã¼le vÃµrgu sinu klastri "juhtimiskeskusesse", mida nimetatakse API Serveriks. See on ainus vÃ¤rav, mille kaudu klastriga suheldakse.
NÃ¤itab vastust: API Server tÃ¶Ã¶tleb pÃ¤ringu, kogub kokku vajaliku info ja saadab selle puldile tagasi. kubectl vormindab selle sinu jaoks kenasti terminalis loetavaks.
Minikube: Sinu Isiklik Kubernetes'e Klaster
Minikube'i eesmÃ¤rk on anda sulle tÃ¤isfunktsionaalne, aga lihtsustatud Kubernetes'e klaster, mis jookseb sinu enda arvutis.

Analoogia: Kujuta ette, et tahad Ãµppida linna planeerimist. Selle asemel, et ehitada pÃ¤ris linna (mis oleks tohutult kallis ja keeruline), ehitad sa oma tuppa vÃ¤ikesele lauale miniatuurse Lego-linna. Selles Lego-linnas on olemas kÃµik olulised hooned: raekoda, postkontor, arhiiv. Minikube ongi sinu Lego-linn. PÃ¤ris Kubernetes'e klaster on pÃ¤ris linn, aga Ãµppimiseks sobib Lego-mudel ideaalselt.

Kuidas see tÃ¶Ã¶tab?
Kui sa kÃ¤ivitasid minikube start, ehitas see sinu Lego-linna valmis, luues Ã¼he Docker'i konteineri, mille sees pandi tÃ¶Ã¶le kÃµik linna olulised teenused (Kubernetes'e juhtplaan ehk Control Plane):

API Server: See on linna raekoda ja postkontor Ã¼hes. KÃµik kÃ¤sud (kubectl pÃ¤ringud) saabuvad siia.
etcd: See on linna arhiiv. Ãœlimalt turvaline ja tÃ¶Ã¶kindel andmebaas, kus hoitakse kirjas absoluutselt kÃµike, mis linnas toimub: millised majad on ehitatud, kellele need kuuluvad jne.
Scheduler: See on linnaarhitekt. Kui keegi tahab ehitada uut maja (Pod'i), siis arhitekt vaatab plaani ja otsustab, millisele vabale krundile (sÃµlmele ehk node'ile) see maja ehitatakse. Minikube'i puhul on meil ainult Ã¼ks krunt.
NÃ¼Ã¼d, kui me mÃµistame oma tÃ¶Ã¶riistu, oleme valmis ehitama oma esimese maja.

Samm 1: Sinu esimene Pod
KÃµige vÃ¤iksem ja fundamentaalsem ehituskivi Kuberneteses on Pod.

Analoogia: Kui Kubernetes on linn, siis Pod on korter kortermajas. Korter ise ei tee midagi, aga see pakub elamiseks vajalikke tingimusi: seinu, elektrit, vett ja Ã¼hte kindlat postiaadressi. Need tingimused ongi konteineri jaoks vajalik jagatud vÃµrguruum ja salvestusruum. Tavaliselt elab korteris Ã¼ks elanik (sinu rakenduse konteiner). MÃµnikord vÃµib seal olla ka vÃ¤ike abiline, kes elab panipaigas (see oleks sidecar-konteiner).

Loome deklaratiivselt oma esimese korteri. See tÃ¤hendab, et me ei anna kÃ¤sku "ehita korter!", vaid anname ehitajale (Kubernetesele) detailse joonise (.yaml fail) ja Ã¼tleme: "tee nii, et reaalsus vastaks sellele joonisele."

Loo fail nimega pod.yaml:

YAML

apiVersion: v1
kind: Pod
metadata:
  name: minu-esimene-pod
  labels:
    app: veebiserver
spec:
  containers:
  - name: nginx-konteiner
    image: nginx
YAML-faili lahkamine:

apiVersion: v1: "Me rÃ¤Ã¤gime API Serveriga keele versioonis 1."
kind: Pod: "Joonise tÃ¼Ã¼p on 'Korter' (Pod)."
metadata: "Korteri andmed."
name: minu-esimene-pod: "Anname korterile nime (uksesildi)."
labels: app: veebiserver: "VÃ¤rvime korteri ukse punaseks (silt app: veebiserver). See on Ã¼lioluline, sest hiljem saame Ã¶elda: 'leia kÃµik punase uksega korterid'."
spec: "Korteri detailne siseplaan."
containers:: "Siin on nimekiri elanikest (konteineritest), kes siin korteris elavad."
- name: nginx-konteiner: "Elaniku nimi on 'nginx-konteiner'."
image: nginx: "See elanik on loodud 'nginx' tÃµmmise (DNA) pÃµhjal."
NÃ¼Ã¼d anname joonise Kubernetes'ele:

Bash

kubectl apply -f pod.yaml
Kontrollime, kas korter sai valmis ja elanik kolis sisse:

Bash

kubectl get pods
NÃ¤eme, et minu-esimene-pod on staatuses Running. NÃ¼Ã¼d koristame selle Ã¤ra, sest me Ãµppisime just, et Podid on surelikud. Me ei taha hallata Ã¼ksikuid kortereid, vaid tervet kortermaja.

Bash

kubectl delete -f pod.yaml
Samm 2: UsaldusvÃ¤Ã¤rne rakendus Deploymentiga
Pod on liiga habras. Kui rakendus jookseb kokku, on Pod surnud. Me vajame kedagi, kes automaatselt uue asemele loob. See keegi on Deployment.

Analoogia: Kui Pod on korter, siis Deployment on kortermaja haldur. Sa ei Ã¼tle haldurile, et "ehita Ã¼ks korter". Sa annad talle maja joonise ja reegli: "Selles majas peab ALATI olema kaks identset, elanikega asustatud korterit (replicas: 2)." Kui Ã¼hes korteris toimub uputus (Pod jookseb kokku), siis haldur mÃ¤rkab seda, sulgeb selle korteri ja ehitab koheselt joonise alusel uue asemele. Sina ei pea sekkuma.

Loome haldurile tÃ¶Ã¶juhendi failis deployment.yaml:

YAML

apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: veebiserver
  template:
    metadata:
      labels:
        app: veebiserver
    spec:
      containers:
      - name: nginx
        image: nginx
        ports:
        - containerPort: 80
TÃ¶Ã¶juhendi lahkamine:

kind: Deployment: "See on tÃ¶Ã¶juhend 'Kortermaja Haldurile'."
replicas: 2: "Halduri pÃµhireegel: alati hoia tÃ¶Ã¶s 2 identset korterit."
selector: "Kuidas haldur teab, millised korterid on tema omad? Ta otsib neid, millel on uksel silt app: veebiserver." See on tema vastutusala.
template: "See on detailne korteri joonis, mida haldur kasutab IGA KORD, kui on vaja uus korter ehitada. Pane tÃ¤hele, et joonisel endal peab olema sama silt (labels: app: veebiserver), et haldur saaks pÃ¤rast ehitamist aru, et see on tema hallatav korter."
Anname tÃ¶Ã¶juhendi haldurile:

Bash

kubectl apply -f deployment.yaml
Kontrollime halduri tÃ¶Ã¶d:

Bash

kubectl get pods
NÃ¤eme kahte NGINX Pod'i, mille haldur on loonud. NÃ¼Ã¼d on meil tÃ¶Ã¶kindel sÃ¼steem!

Samm 3: Rakenduse kÃ¤ttesaadavaks tegemine Service'iga
Meil on nÃ¼Ã¼d kaks korterit, aga nende uksekoodid (IP-aadressid) on ajutised. Kui haldur ehitab uue korteri, saab see uue uksekoodi. Kuidas saaksime saata kirja "NGINX elanikele", kui me ei tea nende tÃ¤pset aadressi? Lahendus on Service.

Analoogia: Service on kortermaja fuajees asuv postkontor vÃµi infopunkt. Sellel postkontoril on Ã¼ks, pÃ¼siv ja avalik aadress (selle ClusterIP ja DNS-nimi). KÃµik kirjad (vÃµrguliiklus) saadetakse sellele aadressile. Postkontori tÃ¶Ã¶taja (selector) vaatab kirja ja teab tÃ¤pselt, millistel ustel on silt app: veebiserver. Ta vÃµtab kirja ja viib selle Ã¼hele neist elanikest. Kui elanikke on mitu, jaotab ta kirjad nende vahel vÃµrdselt Ã¤ra (see ongi koormuse jaotamine ehk load balancing).

Loome postkontorile reeglid failis service.yaml:

YAML

apiVersion: v1
kind: Service
metadata:
  name: minu-nginx-service
spec:
  type: ClusterIP
  selector:
    app: veebiserver
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
Postkontori reeglite lahkamine:

type: ClusterIP: "See postkontor teenindab ainult maja-siseseid kirju (liiklus on avatud ainult klastri sees)."
selector: app: veebiserver: "PostitÃ¶Ã¶taja reegel: vii kirjad edasi ainult neile korteritele, mille uksel on silt app: veebiserver." See Ã¼hendab postkontori Ãµigete korteritega.
ports: "Kuidas kirju vastu vÃµetakse ja edastatakse."
port: 80: "Kirja vastuvÃµtmise postkasti number fuajees on 80."
targetPort: 80: "Korteri ukse kÃ¼ljes oleva postipilu number, kuhu kiri tuleb panna, on samuti 80."
Avame postkontori:

Bash

kubectl apply -f service.yaml
Kontrollime, kas postkontor tÃ¶Ã¶tab:

Bash

kubectl get service minu-nginx-service
VÃ¤ljund nÃ¤itab, et meie teenusel on nÃ¼Ã¼d stabiilne, maja-sisene aadress (CLUSTER-IP).

KokkuvÃµte
Palju Ãµnne! Sa oled edukalt loonud oma esimese rakenduse Kuberneteses, kasutades selleks professionaalseid ja tÃ¶Ã¶kindlaid meetodeid.

Mida sa tÃ¤na Ãµppisid lÃ¤bi analoogiate:

Sa mÃµistad pÃµhilisi tÃ¶Ã¶riistu: kubectl on sinu pult ja Minikube on sinu isiklik Lego-linn.
Sa tead, mis on Kubernetes'e ehituskivid: Pod on korter, Deployment on tark maja haldur ja Service on maja postkontor.
Sa oskad luua tÃ¶Ã¶kindla ja skaleeritava rakenduse, mis suudab end ise parandada.
Hetkel on meie rakendus kÃ¤ttesaadav ainult klastri seest (maja-siseselt). Meie seeria jÃ¤rgmises postituses vaatame, kuidas oma rakendus turvaliselt ka vÃ¤lismaailmale avada, ehitades maja ette korraliku sissepÃ¤Ã¤su â€“ selleks kasutame Ingress'i. PÃ¼sige lainel!


Sources





tee mulle prompt selle artikli jaoks visuaali loomiseks AI abil



Show thinking
Muidugi, siin on prompt, mis on loodud spetsiaalselt sinu pÃµhjaliku ja analoogiate-rohke artikli jaoks. Prompt on inglise keeles, kuna enamik AI pildigeneraatoreid tÃ¶Ã¶tab sellega kÃµige paremini, aga lisan ka eestikeelse seletuse.

Eestikeelne selgitus ja idee
Pildi eesmÃ¤rk on visuaalselt edasi anda artiklis kasutatud analoogiaid: Kubernetes kui dirigent, arhitekt vÃµi linnaehitaja, kes loob korrastatud sÃ¼steemi vÃ¤iksematest ehitusklotsidest (konteineritest). Visuaal peaks olema puhas, moderne ja tehnoloogiline, sobides Pilvio brÃ¤ndi ja Digital Oceani stiiliga.

Prompt AI pildigeneraatori jaoks (nt Midjourney, DALL-E 3, Stable Diffusion)
English Prompt:

A minimalist and futuristic vector illustration for a tech blog header. The central theme is "Kubernetes Orchestration".

An abstract, luminous figure, acting as a conductor or architect, is orchestrating the construction of a city. The city's buildings are made of neatly stacked, glowing cubes in shades of blue and green, representing software containers.

Holographic lines and data streams flow from the architect's hands to the cubes, symbolizing control, automation, and networking. The background is a dark, deep blue, making the glowing elements stand out.

The overall aesthetic should be clean, sophisticated, and convey a sense of order being created from complexity.
LÃ¼hem ja otsem prompt, kui eelnev on liiga detailne:

A minimalist vector illustration of an abstract figure orchestrating glowing blue cubes into organized stacks, symbolizing Kubernetes container orchestration. Set against a dark background, with clean lines and a futuristic tech aesthetic.
Miks see prompt tÃ¶Ã¶tab hÃ¤sti sinu artikliga:

"Minimalist and futuristic vector illustration": See tagab puhta ja professionaalse stiili, mis sobib tehnoloogia-blogile.
"Abstract, luminous figure, acting as a conductor or architect": See kasutab otse sinu artikli parimaid analoogiaid.
"City's buildings are made of neatly stacked, glowing cubes": See visualiseerib konteinereid kui korrastatud ehitusklotse, mitte kaootilist hunnikut. VÃ¤rvid (sinine, roheline) on tehnoloogiamaailmas levinud.
"Holographic lines and data streams": See nÃ¤itab automatiseerimist ja Ã¼henduvust (nagu Service), muutes pildi dÃ¼naamiliseks.
"Sense of order being created from complexity": See vÃµtab kokku Kubernetes'e peamise vÃ¤Ã¤rtuspakkumise ja sinu artikli eesmÃ¤rgi.





jÃ¤tkame nÃ¼Ã¼d Ãµppimisega! mis jÃ¤rgmiseks oli?



Show thinking
Absoluutselt! VÃ¤ga hea meel on jÃ¤tkata.

Meie teekonnal oleme jÃµudnud punkti, kus meil on:

TÃ¶Ã¶kindel rakendus, mis jookseb Deployment'i abil.
Stabiilne, klastri-sisene vÃµrguaadress sellele rakendusele tÃ¤nu Service'ile.
Praegune probleem on see, et meie rakendus on kÃ¤ttesaadav ainult klastri seest. Keegi vÃ¤lismaailmast ei pÃ¤Ã¤se sellele ligi. JÃ¤rgmine loogiline samm on see uks avada.

Selleks on meil Step 4.

Samm 4: Rakenduse Avamine VÃ¤lismaailmale Ingressiga
Kuidas me saame vÃ¤lise liikluse turvaliselt ja arukalt oma klastris oleva teenuseni suunata? Ãœks vÃµimalus oleks muuta meie Service'i tÃ¼Ã¼biks NodePort vÃµi LoadBalancer, aga need on sageli kohmakad vÃµi kallid, eriti kui sul on kÃ¼mneid erinevaid teenuseid.

KÃµige levinum ja paindlikum viis on kasutada Ingressi.

Mis on Ingress?

Ingress koosneb kahest osast:

Ingress Controller: See on reaalne rakendus (spetsiaalne Pod), mis jookseb sinu klastris. MÃµtle sellest kui arukast vÃ¤ravavahist vÃµi ruuterist, mis seisab sinu klastri vÃ¤ravas ja vÃµtab vastu kogu sissetuleva liikluse. Populaarseim on NGINX Ingress Controller.
Ingress Resource: See on puhas konfiguratsioon â€“ reeglite kogumik, mille sina kirjutad. Sa Ã¼tled sellega vÃ¤ravavahile (Ingress Controllerile), kuidas liiklust suunata. NÃ¤iteks: "Kui keegi tuleb aadressilt minuapp.com/login, saada ta sisse 'kasutajate' teenuse juurde. Kui keegi tuleb aadressilt pood.minuapp.com, saada ta 'toodete' teenuse juurde."
Analoogia: MÃµtle oma klastrist kui suurest bÃ¼roohoonest (varem oli see kortermaja, aga nÃ¼Ã¼d on Ã¤rihoone!). Service on nagu iga firma sisene suunakood telefonil. Aga kuidas saab klient tÃ¤navalt helistada kindlale firmale? Ta helistab hoone Ã¼ldnumbrile. Sellele numbrile vastab automaatvastaja (Ingress Controller). Sina oled programmeerinud automaatvastajasse reeglid (Ingress Resource): "kui soovid rÃ¤Ã¤kida 'MÃ¼Ã¼giosakonnaga', vali 1; kui soovid rÃ¤Ã¤kida 'Raamatupidamisega', vali 2". Automaatvastaja suunab seejÃ¤rel kÃµne Ãµigele siseliinile (meie my-nginx-service'ile).

Sinu tegevused Sammus 4:

Loo uuesti eelmise sammu ressursid:
Kuna me eelmise sammu lÃµpus koristasime, peame oma Deployment'i ja Service'i uuesti looma, et Ingressil oleks, kuhu liiklust suunata. Kui sul on deployment.yaml ja service.yaml alles, siis kÃ¤ivita:

Bash

kubectl apply -f deployment.yaml
kubectl apply -f service.yaml
Veendu, et Podid ja Service tÃ¶Ã¶tavad: kubectl get pods,svc.

Aktiveeri Ingress Controller Minikube'is:
Minikube'il on kaasas mitu kasulikku lisa (addon), mida saab lihtsalt sisse lÃ¼litada. Meie aktiveerime NGINX Ingress Controlleri.

Bash

minikube addons enable ingress
Oodatav tulemus: NÃ¤ed teadet, et Ingressi lisandmoodul on aktiveeritud. Minikube kÃ¤ivitab nÃ¼Ã¼d taustal vajalikud Podid Ingress Controlleri jaoks.
Hangi Minikube'i IP-aadress:
Meil on vaja teada, milline on meie klastri vÃ¤line "Ã¼ldnumber". Minikube'i puhul on see Minikube'i enda IP-aadress.

Bash

minikube ip
Oodatav tulemus: Saad vÃ¤ljundiks IP-aadressi, nÃ¤iteks 192.168.49.2. Pane see aadress endale kirja.
Loo Ingressi reegel (Resource):
NÃ¼Ã¼d loome reegli, mis Ã¼tleb kontrollerile: "kui keegi kÃ¼sib domeeninime minu-app.info, suuna tema pÃ¤ring edasi teenusele nimega my-nginx-service pordil 80."
Loo fail nimega ingress.yaml:

YAML

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: minu-app-ingress
spec:
  rules:
  - host: "minu-app.info"
    http:
      paths:
      - pathType: Prefix
        path: "/"
        backend:
          service:
            name: my-nginx-service
            port:
              number: 80
Rakenda Ingressi reegel:

Bash

kubectl apply -f ingress.yaml
Simuleeri DNS-kirjet:
Tavaliselt seoksid sa oma domeeni (minu-app.info) DNS-i kaudu oma serveri IP-aadressiga. Kuna meil pole pÃ¤ris domeeni, saame seda oma arvutis simuleerida, muutes hosts faili. See paneb sinu arvuti arvama, et minu-app.info asub sinu Minikube'i IP-aadressil.

Ava /etc/hosts fail administraatori Ãµigustes (nÃ¤iteks sudo nano /etc/hosts) ja lisa selle lÃµppu uus rida. Asenda 192.168.49.2 oma Minikube'i IP-aadressiga, mille sa 3. punktis said.

# Lisa see rida /etc/hosts faili
192.168.49.2   minu-app.info
Salvesta fail.

Testi tulemust!
NÃ¼Ã¼d on kÃµik seadistatud. Ava oma terminal (mitte see, mis on Pod'i sees, vaid sinu enda arvuti terminal) ja tee curl pÃ¤ring.

Bash

curl http://minu-app.info
Oodatav tulemus: Sa peaksid nÃ¤gema "Welcome to nginx!" HTML-lehte!
Mis just juhtus?
a. Sinu arvuti vaatas hosts failist ja saatis pÃ¤ringu minu-app.info kohta sinu Minikube'i IP-le.
b. PÃ¤ringu vÃµttis vastu Ingress Controller (meie vÃ¤ravavaht).
c. Ingress Controller vaatas oma reegleid (ingress.yaml sisu) ja nÃ¤gi, et domeeni minu-app.info liiklus tuleb suunata teenusele my-nginx-service.
d. Ingress Controller suunas pÃ¤ringu edasi Service'ile.
e. Service saatis pÃ¤ringu Ã¼hele kahest NGINX Pod'ist.
f. NGINX Pod saatis vastuse tagasi mÃ¶Ã¶da sama teed.

Koristamine:
Kui oled katsetamise lÃµpetanud, saad kÃµik loodud ressursid kustutada.

Bash

kubectl delete -f deployment.yaml
kubectl delete -f service.yaml
kubectl delete -f ingress.yaml
Ã„ra unusta eemaldada rida, mille lisasid /etc/hosts faili!

Palju Ãµnne! See oli vÃ¤ga oluline samm. Sa oled nÃ¼Ã¼d vÃµimeline oma klastris jooksvaid rakendusi turvaliselt ja paindlikult vÃ¤lismaailmale avama. See on muster, mida kasutatakse vÃ¤ga paljudes reaalsetes Kubernetes'e paigaldustes.

Kui oled valmis, vÃµime edasi liikuda ja vaadata, kuidas oma rakendustele konfiguratsiooni ja salajasi andmeid (nagu paroolid ja API vÃµtmed) hallata.







Allpool on meie Kuberenetese Ãµppimise artiklisarja esimene artikkel. Soovin, et seda tÃ¤iustaksid:

- aita mul artiklile SEO ja conversioni jaoks hea pealkiri mÃµelda

- artikli alguses on frontmatter, Ã¤ra seda puutu (va. uus pealkiri ja brief description, kui sul on hÃ¤id ideid)

- kirjuta sissejuhatus, kus rÃ¤Ã¤gid artiklite sarjast ja paned selle artikli konteksti. koosta mulle curriculum Kuberenetese Ãµppimise jaoks ja kirjelda seda sissejuhatuses

- Ã¤ra kasuta pealkirjades lÃ¤bivaid suurtÃ¤hti

- kohad artiklis, kus on bash kÃ¤skude kÃ¤ivitamine, too Ã¤ra ka oodatav output, et Ãµppur saaks vÃµrrelda

- igal pool vÃµiks olla rohkem konteksti, et kus me protsessis parasjagu oleme



---

title: "Sissejuhatus Kubernetesesse: Sinu esimene rakendus"Â  Â  Â  Â  Â  Â # Required: Post title

author: "Pilvio Admin Team"Â  Â  Â  Â  Â  Â  Â  Â  Â  Â # Required: Author name

publishedAt: "16. juuni 2025"Â  Â  Â  Â  # Required: Estonian format date

category: "Ã•petused"Â  Â  Â  Â  Â  Â  Â  Â  Â  # Required: Post category

tags: ["kubernetes", "devops"]Â  Â  Â  Â  Â  # Required: Array of tags

excerpt: "Selles postituses juhendame sind lÃ¤bi Kubernetes'e pÃµhikontseptsioonide, alustades sinu esimese rakenduse paigaldamisest kuni selle kÃ¤ttesaadavaks tegemiseni klastri sees.

"Â  Â  Â  Â  Â # Optional: Custom excerpt (auto-generated if not provided)

imageUrl: "/media/kubernetes_intro_1.png" # Optional: Featured image URL

slug: "sissejuhatus-kubernetesesse-1"Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  # Optional: Custom URL slug (auto-generated from title if not provided)

---

### Sissejuhatus Kubernetesesse: Sinu esimene rakendus



Tere tulemast meie blogiseeriasse, mis on pÃ¼hendatud Kubernetesesse sisseelamisele! See on esimene postitus, mis aitab sul astuda esimesi samme konteinerite orkestreerimismaailmas. Kubernetes, tihti lÃ¼hendatud kui K8s, on vÃµimas avatud lÃ¤htekoodiga platvorm, mis automatiseerib konteineriseeritud rakenduste paigaldamist, skaleerimist ja haldamist.



MÃµtle Kubernetesest kui sÃ¼mfooniaorkestri dirigendist. Sinu rakendused on muusikud. Dockeriga saad sa Ã¶elda igale muusikule (konteinerile), mida mÃ¤ngida. Aga Kubernetes on dirigent, kes juhatab kogu orkestrit: ta tagab, et kÃµik alustavad Ãµigel ajal, mÃ¤ngivad harmoonias, asendab muusiku, kui see peaks Ã¤ra vÃ¤sima, ja toob juurde uusi viiuleid, kui muusika peab muutuma vÃµimsamaks.



Selles postituses juhendame sind lÃ¤bi Kubernetes'e pÃµhikontseptsioonide, alustades sinu esimese rakenduse paigaldamisest kuni selle kÃ¤ttesaadavaks tegemiseni klastri sees.



#### Eeldused



Enne alustamist eeldame, et sul on:



- PÃµhiteadmised Dockerist ja konteineritest. Sa mÃµistad, mis on tÃµmmis (`image`) ja mis on konteiner.

- Soov Ãµppida ja katsetada kÃ¤sureal.



Selles juhendis kasutame kohaliku arenduskeskkonna jaoks Minikube'i. **Siin Pilvios oleme kirjutanud eraldi pÃµhjaliku juhendi**, kuidas seadistada Minikube koos Terraformiga meie platvormil. Palun jÃ¤rgi neid juhiseid, et oma Kubernetes'e testkeskkond pÃ¼sti panna: [Kuidas paigaldada Minikube Pilvios Terraformiga](https://blog.pilvio.com/blog/minikube-terraform).



Kui oled sellega valmis, liigume edasi.



### TÃ¶Ã¶riistade MÃµistmine: `kubectl` ja Minikube



Enne kui loome oma esimese rakenduse, on Ã¼lioluline mÃµista kahte pÃµhilist tÃ¶Ã¶riista, mille just seadistasid: `kubectl` ja Minikube.



#### `kubectl`: Sinu Kaugjuhtimispult



`kubectl` (hÃ¤Ã¤ldatakse "kjuub-kontroll") on sinu peamine ja kÃµige olulisem tÃ¶Ã¶riist Kubernetes'e klastriga suhtlemiseks.



**Analoogia:** MÃµtle `kubectl`-ist kui oma teleri kaugjuhtimispuldist. Pult ise ei tea, kuidas teleri sisemine elektroonika pilti tekitab. Sa lihtsalt vajutad nuppu "Kanal 5" ja teler teab, mida teha. `kubectl` on samasugune â€“ sa annad kÃ¤su (`kubectl get pods`) ja ei pea muretsema, kuidas klaster selle info tÃ¤pselt hangib. Sa suhtled ainult puldiga, mitte ei hakka teleri tagapaneeli lahti kruvima.



Kuidas see tÃ¶Ã¶tab?



Iga kord, kui sa kÃ¤ivitad kÃ¤su, teeb kubectl jÃ¤rgmist:



1. **Loeb konfiguratsiooni:** Sinu kodukataloogis on peidetud fail `.kube/config`. See on nagu puldi ja teleri "paaristamise" info. Sinna on kirja pandud sinu Minikube'i klastri unikaalne aadress ja turvavÃµtmed, mis tÃµestavad, et just sinul on Ãµigus sellele klastrile kÃ¤ske anda.

2. **Saadab API pÃ¤ringu:** `kubectl` vormistab sinu kÃ¤su standardseks API-pÃ¤ringuks ja saadab selle Ã¼le vÃµrgu sinu klastri "juhtimiskeskusesse", mida nimetatakse **API Serveriks**. See on ainus vÃ¤rav, mille kaudu klastriga suheldakse.

3. **NÃ¤itab vastust:** API Server tÃ¶Ã¶tleb pÃ¤ringu, kogub kokku vajaliku info ja saadab selle puldile tagasi. `kubectl` vormindab selle sinu jaoks kenasti terminalis loetavaks.



#### Minikube: Sinu Isiklik Kubernetes'e Klaster



Minikube'i eesmÃ¤rk on anda sulle tÃ¤isfunktsionaalne, aga lihtsustatud Kubernetes'e klaster, mis jookseb sinu enda arvutis.



**Analoogia:** Kujuta ette, et tahad Ãµppida linna planeerimist. Selle asemel, et ehitada pÃ¤ris linna (mis oleks tohutult kallis ja keeruline), ehitad sa oma tuppa vÃ¤ikesele lauale miniatuurse Lego-linna. Selles Lego-linnas on olemas kÃµik olulised hooned: raekoda, postkontor, arhiiv. Minikube ongi sinu Lego-linn. PÃ¤ris Kubernetes'e klaster on pÃ¤ris linn, aga Ãµppimiseks sobib Lego-mudel ideaalselt.



Kuidas see tÃ¶Ã¶tab?



Kui sa kÃ¤ivitasid minikube start, ehitas see sinu Lego-linna valmis, luues Ã¼he Docker'i konteineri, mille sees pandi tÃ¶Ã¶le kÃµik linna olulised teenused (Kubernetes'e juhtplaan ehk Control Plane):



- **API Server:** See on linna raekoda ja postkontor Ã¼hes. KÃµik kÃ¤sud (`kubectl` pÃ¤ringud) saabuvad siia.

- **etcd:** See on linna arhiiv. Ãœlimalt turvaline ja tÃ¶Ã¶kindel andmebaas, kus hoitakse kirjas absoluutselt kÃµike, mis linnas toimub: millised majad on ehitatud, kellele need kuuluvad jne.

- **Scheduler:** See on linnaarhitekt. Kui keegi tahab ehitada uut maja (Pod'i), siis arhitekt vaatab plaani ja otsustab, millisele vabale krundile (sÃµlmele ehk *node*'ile) see maja ehitatakse. Minikube'i puhul on meil ainult Ã¼ks krunt.



NÃ¼Ã¼d, kui me mÃµistame oma tÃ¶Ã¶riistu, oleme valmis ehitama oma esimese maja.



### Samm 1: Sinu esimene Pod



KÃµige vÃ¤iksem ja fundamentaalsem ehituskivi Kuberneteses on **Pod**.



**Analoogia:** Kui Kubernetes on linn, siis **Pod on korter** kortermajas. Korter ise ei tee midagi, aga see pakub elamiseks vajalikke tingimusi: seinu, elektrit, vett ja Ã¼hte kindlat postiaadressi. Need tingimused ongi konteineri jaoks vajalik jagatud vÃµrguruum ja salvestusruum. Tavaliselt elab korteris Ã¼ks elanik (sinu rakenduse konteiner). MÃµnikord vÃµib seal olla ka vÃ¤ike abiline, kes elab panipaigas (see oleks *sidecar*-konteiner).



Loome deklaratiivselt oma esimese korteri. See tÃ¤hendab, et me ei anna kÃ¤sku "ehita korter!", vaid anname ehitajale (Kubernetesele) detailse joonise (`.yaml` fail) ja Ã¼tleme: "tee nii, et reaalsus vastaks sellele joonisele."



Loo fail nimega `pod.yaml`:



YAML



```

apiVersion: v1

kind: Pod

metadata:

Â  name: minu-esimene-pod

Â  labels:

Â  Â  app: veebiserver

spec:

Â  containers:

Â  - name: nginx-konteiner

Â  Â  image: nginx

```



**YAML-faili lahkamine:**



- `apiVersion: v1`: "Me rÃ¤Ã¤gime API Serveriga keele versioonis 1."



- `kind: Pod`: "Joonise tÃ¼Ã¼p on 'Korter' (Pod)."



- `metadata`: "Korteri andmed."

Â  - `name: minu-esimene-pod`: "Anname korterile nime (uksesildi)."

Â  - `labels: app: veebiserver`: "VÃ¤rvime korteri ukse punaseks (silt `app: veebiserver`). See on Ã¼lioluline, sest hiljem saame Ã¶elda: 'leia kÃµik punase uksega korterid'."



- `spec`: "Korteri detailne siseplaan."

Â  - `containers:`: "Siin on nimekiri elanikest (konteineritest), kes siin korteris elavad."

Â  - `- name: nginx-konteiner`: "Elaniku nimi on 'nginx-konteiner'."

Â  - `image: nginx`: "See elanik on loodud 'nginx' tÃµmmise (DNA) pÃµhjal."



NÃ¼Ã¼d anname joonise Kubernetes'ele:



Bash



```

kubectl apply -f pod.yaml

```



Kontrollime, kas korter sai valmis ja elanik kolis sisse:



Bash



```

kubectl get pods

```



NÃ¤eme, et `minu-esimene-pod` on staatuses `Running`. NÃ¼Ã¼d koristame selle Ã¤ra, sest me Ãµppisime just, et Podid on surelikud. Me ei taha hallata Ã¼ksikuid kortereid, vaid tervet kortermaja.



Bash



```

kubectl delete -f pod.yaml

```



### Samm 2: UsaldusvÃ¤Ã¤rne rakendus Deploymentiga



Pod on liiga habras. Kui rakendus jookseb kokku, on Pod surnud. Me vajame kedagi, kes automaatselt uue asemele loob. See keegi on **Deployment**.



**Analoogia:** Kui Pod on korter, siis **Deployment on kortermaja haldur**. Sa ei Ã¼tle haldurile, et "ehita Ã¼ks korter". Sa annad talle maja joonise ja reegli: "Selles majas peab ALATI olema kaks identset, elanikega asustatud korterit (`replicas: 2`)." Kui Ã¼hes korteris toimub uputus (Pod jookseb kokku), siis haldur mÃ¤rkab seda, sulgeb selle korteri ja ehitab koheselt joonise alusel uue asemele. Sina ei pea sekkuma.



Loome haldurile tÃ¶Ã¶juhendi failis `deployment.yaml`:







YAML



```

apiVersion: apps/v1

kind: Deployment

metadata:

Â  name: nginx-deployment

spec:

Â  replicas: 2

Â  selector:

Â  Â  matchLabels:

Â  Â  Â  app: veebiserver

Â  template:

Â  Â  metadata:

Â  Â  Â  labels:

Â  Â  Â  Â  app: veebiserver

Â  Â  spec:

Â  Â  Â  containers:

Â  Â  Â  - name: nginx

Â  Â  Â  Â  image: nginx

Â  Â  Â  Â  ports:

Â  Â  Â  Â  - containerPort: 80

```



**TÃ¶Ã¶juhendi lahkamine:**



- `kind: Deployment`: "See on tÃ¶Ã¶juhend 'Kortermaja Haldurile'."

- `replicas: 2`: "Halduri pÃµhireegel: alati hoia tÃ¶Ã¶s 2 identset korterit."

- `selector`: "Kuidas haldur teab, millised korterid on tema omad? Ta otsib neid, millel on uksel silt `app: veebiserver`." See on tema vastutusala.

- `template`: "See on detailne korteri joonis, mida haldur kasutab IGA KORD, kui on vaja uus korter ehitada. Pane tÃ¤hele, et joonisel endal peab olema sama silt (`labels: app: veebiserver`), et haldur saaks pÃ¤rast ehitamist aru, et see on tema hallatav korter."



Anname tÃ¶Ã¶juhendi haldurile:



Bash



```

kubectl apply -f deployment.yaml

```



Kontrollime halduri tÃ¶Ã¶d:



Bash



```

kubectl get pods

```



NÃ¤eme kahte NGINX Pod'i, mille haldur on loonud. NÃ¼Ã¼d on meil tÃ¶Ã¶kindel sÃ¼steem!



### Samm 3: Rakenduse kÃ¤ttesaadavaks tegemine Service'iga



Meil on nÃ¼Ã¼d kaks korterit, aga nende uksekoodid (IP-aadressid) on ajutised. Kui haldur ehitab uue korteri, saab see uue uksekoodi. Kuidas saaksime saata kirja "NGINX elanikele", kui me ei tea nende tÃ¤pset aadressi? Lahendus on **Service**.



**Analoogia:** **Service on kortermaja fuajees asuv postkontor vÃµi infopunkt**. Sellel postkontoril on Ã¼ks, pÃ¼siv ja avalik aadress (selle `ClusterIP` ja DNS-nimi). KÃµik kirjad (vÃµrguliiklus) saadetakse sellele aadressile. Postkontori tÃ¶Ã¶taja (`selector`) vaatab kirja ja teab tÃ¤pselt, millistel ustel on silt `app: veebiserver`. Ta vÃµtab kirja ja viib selle Ã¼hele neist elanikest. Kui elanikke on mitu, jaotab ta kirjad nende vahel vÃµrdselt Ã¤ra (see ongi koormuse jaotamine ehk *load balancing*).



Loome postkontorile reeglid failis `service.yaml`:



YAML



```

apiVersion: v1

kind: Service

metadata:

Â  name: minu-nginx-service

spec:

Â  type: ClusterIP

Â  selector:

Â  Â  app: veebiserver

Â  ports:

Â  Â  - protocol: TCP

Â  Â  Â  port: 80

Â  Â  Â  targetPort: 80

```



**Postkontori reeglite lahkamine:**



- `type: ClusterIP`: "See postkontor teenindab ainult maja-siseseid kirju (liiklus on avatud ainult klastri sees)."



- `selector: app: veebiserver`: "PostitÃ¶Ã¶taja reegel: vii kirjad edasi ainult neile korteritele, mille uksel on silt `app: veebiserver`." See Ã¼hendab postkontori Ãµigete korteritega.



- `ports`: "Kuidas kirju vastu vÃµetakse ja edastatakse."

Â  - `port: 80`: "Kirja vastuvÃµtmise postkasti number fuajees on 80."

Â  - `targetPort: 80`: "Korteri ukse kÃ¼ljes oleva postipilu number, kuhu kiri tuleb panna, on samuti 80."



Avame postkontori:



Bash



```

kubectl apply -f service.yaml

```



Kontrollime, kas postkontor tÃ¶Ã¶tab:



Bash



```

kubectl get service minu-nginx-service

```



VÃ¤ljund nÃ¤itab, et meie teenusel on nÃ¼Ã¼d stabiilne, maja-sisene aadress (`CLUSTER-IP`).



### KokkuvÃµte



Palju Ãµnne! Sa oled edukalt loonud oma esimese rakenduse Kuberneteses, kasutades selleks professionaalseid ja tÃ¶Ã¶kindlaid meetodeid.



Mida sa tÃ¤na Ãµppisid lÃ¤bi analoogiate:



- Sa mÃµistad pÃµhilisi tÃ¶Ã¶riistu: **`kubectl`** on sinu pult ja **Minikube** on sinu isiklik Lego-linn.

- Sa tead, mis on Kubernetes'e ehituskivid: **Pod** on korter, **Deployment** on tark maja haldur ja **Service** on maja postkontor.

- Sa oskad luua tÃ¶Ã¶kindla ja skaleeritava rakenduse, mis suudab end ise parandada.



Hetkel on meie rakendus kÃ¤ttesaadav ainult klastri seest (maja-siseselt). Meie seeria jÃ¤rgmises postituses vaatame, kuidas oma rakendus turvaliselt ka vÃ¤lismaailmale avada, ehitades maja ette korraliku sissepÃ¤Ã¤su â€“ selleks kasutame **Ingress**'i. PÃ¼sige lainel!



HÃ¤sti, siin on sinu artikli tÃ¤iustatud ja rikastatud versioon, mis arvestab kÃµiki su soove.

---
title: "Praktiline sissejuhatus Kubernetesesse: sinu esimene rakendus (1. osa)"
author: "Pilvio Admin Team"
publishedAt: "16. juuni 2025"
category: "Ã•petused"
tags: ["kubernetes", "devops", "alustamine", "Ãµpetus"]
excerpt: "Alusta oma teekonda Kubernetesega! See on meie artiklisarja esimene osa, kus Ãµpid praktiliste nÃ¤idete varal selgeks Pod'i, Deployment'i ja Service'i pÃµhimÃµtted."
imageUrl: "/media/kubernetes_intro_1.png"
slug: "praktiline-sissejuhatus-kubernetesesse-1"
---
Tere tulemast Kubernetes'e maailma!
Tere tulemast meie uude artiklisarja "Nullist kangelaseks Kubernetesega"! See sari on mÃµeldud kÃµigile, kes soovivad samm-sammult ja praktiliste nÃ¤idete varal selgeks Ãµppida Kubernetes'e â€“ tÃ¤napÃ¤eva Ã¼he olulisima konteinerite orkestreerimise platvormi.

Oled sa arendaja, kes tahab oma rakendusi paremini hallata, vÃµi sÃ¼steemiadministraator, kes ehitab tulevikukindlaid lahendusi, see sari on just sulle. Me ei uputa sind kuiva teooriasse, vaid ehitame koos, klots klotsi haaval, toimiva sÃ¼steemi, seletades iga sammu juures lahti, miks me midagi teeme.

Selleks, et teekond oleks selge, oleme koostanud jÃ¤rgmise Ãµppekava, millega liigume algaja tasemelt enesekindla kasutaja tasemeni:

1. osa: Aluste loomine (see artikkel)

Mis on Kubernetes ja miks seda vaja on?
TÃ¶Ã¶riistade (kubectl, Minikube) seadistamine ja mÃµistmine.
PÃµhikontseptsioonid: Pod, Deployment ja Service. EesmÃ¤rk on saada lihtne rakendus klastri-siseselt tÃ¶Ã¶le.
2. osa: Rakenduse avalikustamine ja konfigureerimine

Rakenduse turvaline avamine vÃ¤lismaailmale Ingress'i abil.
Rakenduse seadete ja paroolide haldamine ConfigMap'ide ja Secret'itega.
3. osa: Andmete pÃ¼sivus ja olekuga rakendused

Kuidas hallata andmebaase ja teisi olekuga rakendusi? Tutvume PersistentVolume'ite ja StatefulSet'idega.
4. osa: JÃ¤lgimine ja automatiseerimine

Kuidas oma klastri ja rakenduste tervisel silma peal hoida?
Sissejuhatus CI/CD torujuhtmetesse â€“ kuidas automatiseerida rakenduse paigaldamist Kubernetesesse.
Selles esimeses osas paneme paika vundamendi. Alustame!

TÃ¶Ã¶riistade ettevalmistus ja mÃµistmine
Kus me oleme? Enne ehitama asumist peame oma tÃ¶Ã¶riistad valmis panema ja nendega tuttavaks saama. See on meie teekonna "Samm 0".

Eeldused
Enne alustamist eeldame, et sul on:

PÃµhiteadmised Dockerist ja konteineritest. Sa mÃµistad, mis on tÃµmmis (image) ja mis on konteiner.
Soov Ãµppida ja katsetada kÃ¤sureal.
Selles juhendis kasutame kohaliku arenduskeskkonna jaoks Minikube'i. Siin Pilvios oleme kirjutanud eraldi pÃµhjaliku juhendi, kuidas seadistada Minikube koos Terraformiga meie platvormil. Palun jÃ¤rgi neid juhiseid, et oma Kubernetes'e testkeskkond pÃ¼sti panna: Kuidas paigaldada Minikube Pilvios Terraformiga.

Kui kubectl ja Minikube on paigaldatud, liigume edasi nende hingeeluga tutvumisele.

kubectl ja Minikube: sinu pult ja mÃ¤nguvÃ¤ljak
Kus me oleme? MÃµistame oma kahte kÃµige olulisemat tÃ¶Ã¶riista. kubectl on sinu "pult" klastriga suhtlemiseks ja Minikube on sinu isiklik "Lego-linn" ehk testklaster.

kubectl: sinu kaugjuhtimispult
kubectl (hÃ¤Ã¤ldatakse "kjuub-kontroll") on sinu peamine ja kÃµige olulisem tÃ¶Ã¶riist Kubernetes'e klastriga suhtlemiseks.

Analoogia: MÃµtle kubectl-ist kui oma teleri kaugjuhtimispuldist. Sa lihtsalt vajutad nuppu "Kanal 5" ja teler teab, mida teha. kubectl on samasugune â€“ sa annad kÃ¤su (kubectl get pods) ja ei pea muretsema, kuidas klaster selle info tÃ¤pselt hangib.

Iga kord, kui sa kÃ¤ivitad kÃ¤su, loeb kubectl sinu kodukataloogist .kube/config faili, kus on kirjas klastri aadress ja turvavÃµtmed. SeejÃ¤rel vormistab ta sinu kÃ¤su API-pÃ¤ringuks ja saadab selle klastri "juhtimiskeskusesse", mida nimetatakse API Serveriks.

Minikube: sinu isiklik Kubernetes'e klaster
Minikube'i eesmÃ¤rk on anda sulle tÃ¤isfunktsionaalne, aga lihtsustatud Kubernetes'e klaster, mis jookseb sinu enda arvutis.

Analoogia: MÃµtle sellest kui miniatuursest Lego-linnast oma laual. PÃ¤ris Kubernetes'e klaster on nagu pÃ¤ris linn, aga Ãµppimiseks sobib Lego-mudel ideaalselt. Selles Lego-linnas on olemas kÃµik olulised hooned:

API Server: Linna raekoda, kuhu kÃµik kÃ¤sud saabuvad.
etcd: Linna turvaline arhiiv, kus hoitakse kogu infot.
Scheduler: Linnaarhitekt, kes otsustab, kuhu uus maja (Pod) ehitada.
NÃ¼Ã¼d, kui me mÃµistame oma tÃ¶Ã¶riistu, oleme valmis ehitama oma esimese maja.

Samm 1: sinu esimene Pod
Kus me oleme? Loome kÃµige lihtsama ja vÃ¤iksema ehitusploki Kuberneteses â€“ Pod'i. See on meie esimene praktiline samm klastri sees.

Analoogia: Kui Kubernetes on linn, siis Pod on korter. Korter pakub elamiseks vajalikke tingimusi (seinu, elektrit, vett), milleks on konteineri jaoks jagatud vÃµrgu- ja salvestusruum.

Loome deklaratiivselt oma esimese korteri, andes Kubernetes'ele detailse joonise (.yaml fail).

Loo oma arvutisse fail nimega pod.yaml:

YAML

apiVersion: v1
kind: Pod
metadata:
  name: minu-esimene-pod
  labels:
    app: veebiserver
spec:
  containers:
  - name: nginx-konteiner
    image: nginx
YAML-faili lahkamine:

kind: Pod: MÃ¤Ã¤rame, et loome "korteri".
metadata: Lisame nimesildi (name) ja vÃ¤rvime ukse punaseks (labels), et selle hiljem Ã¼les leiaksime.
spec: Kirjeldame korteri sisu â€“ Ã¼he elaniku (container), kes on loodud nginx tÃµmmise (DNA) pÃµhjal.
NÃ¼Ã¼d anname joonise Kubernetes'ele kÃ¤suga kubectl apply:

Bash

kubectl apply -f pod.yaml
Oodatav tulemus:

pod/minu-esimene-pod created
Kontrollime, kas korter sai valmis ja elanik kolis sisse:

Bash

kubectl get pods
Oodatav tulemus:

NAME               READY   STATUS    RESTARTS   AGE
minu-esimene-pod   1/1     Running   0          30s
NÃ¤eme, et Pod on staatuses Running. Kuna aga Pod'id on surelikud ja me tahame ehitada tÃ¶Ã¶kindlamaid sÃ¼steeme, siis koristame selle Ã¼ksiku korteri kohe Ã¤ra.

Bash

kubectl delete -f pod.yaml
Oodatav tulemus:

pod "minu-esimene-pod" deleted
Samm 2: tÃ¶Ã¶kindel rakendus Deployment'iga
Kus me oleme? Liigume edasi Ã¼ksikult "korterilt" terve "kortermaja" haldamise juurde. Loome Deployment'i, mis tagab, et meie rakendus on alati tÃ¶Ã¶s.

Analoogia: Kui Pod on korter, siis Deployment on kortermaja haldur. Sa annad talle reegli: "Selles majas peab ALATI olema kaks identset korterit (replicas: 2)." Kui Ã¼ks korter lÃ¤heb katki, ehitab haldur kohe uue asemele.

Loome haldurile tÃ¶Ã¶juhendi failis deployment.yaml:

YAML

apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: veebiserver
  template:
    metadata:
      labels:
        app: veebiserver
    spec:
      containers:
      - name: nginx
        image: nginx
        ports:
        - containerPort: 80
TÃ¶Ã¶juhendi lahkamine:

replicas: 2: Halduri pÃµhireegel â€“ hoia tÃ¶Ã¶s 2 identset Pod'i.
selector: Kuidas haldur teab, millised Pod'id on tema omad? Ta otsib neid, millel on silt app: veebiserver.
template: See on detailne korteri joonis, mille alusel haldur uusi Pod'e ehitab.
Anname tÃ¶Ã¶juhendi haldurile:

Bash

kubectl apply -f deployment.yaml
Oodatav tulemus:

deployment.apps/nginx-deployment created
Kontrollime halduri tÃ¶Ã¶d:

Bash

kubectl get pods
Oodatav tulemus:

NAME                                READY   STATUS    RESTARTS   AGE
nginx-deployment-7848d4b8d5-7c5jc   1/1     Running   0          25s
nginx-deployment-7848d4b8d5-x5zvm   1/1     Running   0          25s
NÃ¤eme kahte NGINX Pod'i, mille haldur on loonud. NÃ¼Ã¼d on meil tÃ¶Ã¶kindel sÃ¼steem!

Samm 3: rakenduse Ã¼hendamine Service'iga
Kus me oleme? Meil on tÃ¶Ã¶kindel rakendus, aga sellel puudub stabiilne aadress klastri sees. Loome Service'i, et anda meie rakendusele pÃ¼siv vÃµrguidentiteet.

Analoogia: Service on kortermaja fuajees asuv postkontor. Sellel on Ã¼ks, pÃ¼siv aadress (ClusterIP). KÃµik kirjad (vÃµrguliiklus) saadetakse sinna ja postkontori tÃ¶Ã¶taja (selector) suunab need Ãµigele elanikule (Pod'ile).

Loome postkontorile reeglid failis service.yaml:

YAML

apiVersion: v1
kind: Service
metadata:
  name: minu-nginx-service
spec:
  type: ClusterIP
  selector:
    app: veebiserver
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
Postkontori reeglite lahkamine:

type: ClusterIP: See postkontor teenindab ainult maja-siseseid kirju.
selector: PostitÃ¶Ã¶taja reegel â€“ suuna kirjad edasi Pod'idele, mille silt on app: veebiserver.
ports: MÃ¤Ã¤rame, et postkontor vÃµtab liiklust vastu pordil 80 ja suunab selle Pod'i pordile 80.
Avame postkontori:

Bash

kubectl apply -f service.yaml
Oodatav tulemus:

service/minu-nginx-service created
Kontrollime, kas postkontor tÃ¶Ã¶tab:

Bash

kubectl get service minu-nginx-service
Oodatav tulemus:

NAME                 TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE
minu-nginx-service   ClusterIP   10.108.111.44   <none>        80/TCP    15s
VÃ¤ljund nÃ¤itab, et meie teenusel on nÃ¼Ã¼d stabiilne, maja-sisene aadress (CLUSTER-IP).

KokkuvÃµte ja jÃ¤rgmised sammud
Kus me oleme? Oleme esimese osa lÃµpus. Sa oled edukalt loonud oma esimese rakenduse Kuberneteses!

Mida sa tÃ¤na Ãµppisid:

MÃµistad pÃµhilisi tÃ¶Ã¶riistu: kubectl on sinu pult ja Minikube on sinu Lego-linn.
Tead Kubernetes'e pÃµhilisi ehituskive: Pod on korter, Deployment on tark maja haldur ja Service on maja postkontor.
Oskad luua tÃ¶Ã¶kindla ja skaleeritava rakenduse, mis on kÃ¤ttesaadav klastri sees.
Hetkel on meie rakendus veel vÃ¤lismaailma eest peidus. Meie sarja teises osas ehitame maja ette korraliku sissepÃ¤Ã¤su, kasutades Ingress'i, et rakendus turvaliselt avalikuks teha. Samuti vaatame, kuidas hallata rakenduse seadeid ja paroole.

PÃ¼si lainel!












Deep Research

Canvas

Your pilw.io chats arenâ€™t used to improve our models. Gemini can make mistakes, including about people, so double-check it. Your privacy & Gemini

